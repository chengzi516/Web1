---
title: 【leetcode】一次解决三道《只出现一次的数字》
cover: https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/1610173947-QjrHlC-LeetCode.png
tags:
  - 刷题
  - c++
categories: 
- 刷题
ai: ture
date: 2023-08-20 11:40:47

---
# :girl:只出现一次的数字

给你一个非空整数数组nums ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。
>示例 1 ：
输入：nums = [2,2,1]
输出：1
示例 2 ：
输入：nums = [4,1,2,1,2]
输出：4
示例 3 ：
输入：nums = [1]
输出：1

链接：https://leetcode.cn/problems/single-number/description/

思路：要解决这个问题，我们可以使用异或运算。异或运算具有以下特性：
对于任何整数 a，a ^ a = 0
对于任何整数 a，a ^ 0 = a
异或运算满足交换律和结合律，即 a ^ b ^ a = b ^ a ^ a = b ^ (a ^ a) = b ^ 0 = b
根据题目要求，数组中只有一个元素出现一次，其余元素都出现两次。我们可以将数组中的所有元素进行异或运算，得到的结果就是剩下的那个只出现一次的元素。

```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
         int x=0;
         for(auto i: nums){
             x^=i;
         }
         return x;
    }
};
```

# :boy:只出现一次的数字 II
给你一个整数数组 nums ，除某个元素仅出现一次外，其余每个元素都恰出现三次。请你找出并返回那个只出现了一次的元素。

你必须设计并实现线性时间复杂度的算法且不使用额外空间来解决此问题。
>示例 1：
输入：nums = [2,2,3,2]
输出：3
示例 2：
输入：nums = [0,1,0,1,0,1,99]
输出：99

链接：https://leetcode.cn/problems/single-number-ii/

思路: 统计所有数字中每个位中1出现的总数，那么对于某个位，`1出现的次数一定是3的倍数+1或3的倍数`，那么对这个数%3得到的结果就是目的数字在该位上的值。此法可以推广至所有其他元素出现k次，寻找唯一出现一次的那个元素。

```cpp
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int res = 0;
        for(int i = 0;i < 32;++i){
            int sum = 0;
            for(int j = 0;j < nums.size();++j){
                sum += (nums[j] >> i) & 1;
            }
            res ^= (sum % 3) << i;
        }
        return res;
    }
};

```


# :woman:只出现一次的数字 III
给你一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。
你必须设计并实现线性时间复杂度的算法且仅使用常量额外空间来解决此问题。

>示例 1：
输入：nums = [1,2,1,3,2,5]
输出：[3,5]
解释：[5, 3] 也是有效的答案。
示例 2：
输入：nums = [-1,0]
输出：[-1,0]
示例 3：
输入：nums = [0,1]
输出：[1,0]

链接：https://leetcode.cn/problems/single-number-iii/


假设我们有一个数组 [2, 4, 6, 8, 10, 4, 6, 2]，其中只有两个元素只出现一次，其他元素都出现了两次。

首先，我们对整个数组进行异或操作，异或结果xorResult = 2 ^ 4 ^ 6 ^ 8 ^ 10 ^ 4 ^ 6 ^ 2 = 8 ^ 10 = 2。

这里的异或操作是将数组中的所有元素进行异或运算，`相同的元素异或结果为0`，只有只出现`一次`的元素会保留下来。

我们可以找到xorResult中为 1 的某一位，记为 mask。这一位说明只出现一次的两个元素在二进制表示中不同的地方。
接下来，我们可以根据 mask 将所有的元素分成两组。对于数组中的任意一个元素 num，如果 num 的二进制表示的第 mask 位为 1，我们将其分到第一组；否则，我们将其分到第二组。
这样，我们就将原问题转化为了两个子问题。在每个子问题中，`数组中只有一个元素出现一次，其余元素都出现两次`。我们可以分别对每个子问题进行异或运算，得到两个只出现一次的元素。

2 的二进制表示为 0000 0010，属于第一组。
4 的二进制表示为 0000 0100，属于第二组。
6 的二进制表示为 0000 0110，属于第一组。
8 的二进制表示为 0000 1000，属于第二组。
10 的二进制表示为 0000 1010，属于第一组。
经过分组后，我们得到两个组：

第一组：[2, 10]
第二组：[4, 6, 8]
此时，8和10这两个只出现一次的被分到了两个组里。

最后，我们分别对这两组元素进行异或操作，得到的结果就是只出现一次的两个元素。


```cpp
class Solution {
public:
    vector<int> singleNumber(vector<int>& nums) {
   int xorResult = 0;
    for (int num : nums) {
        xorResult ^= num;
    }
    
    int mask = 1;  //找到xorresult中的一个1即可
    while ((xorResult & mask) == 0) {
        mask <<= 1;
    }
    
    int num1 = 0, num2 = 0;
    for (int num : nums) {
        if ((num & mask) == 0) {
            num1 ^= num;
        } else {
            num2 ^= num;
        }
    }
    
    return {num1, num2};
    }
};
```