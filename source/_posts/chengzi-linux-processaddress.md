---
title: 【linux】初识进程地址空间
date: 2023-10-09 19:48:44
tags:
- 进程
- linux
categories:
- linux
cover: https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/linux.jpg
ai: true
---

# 引入

先来看一段代码：
```c
int main()
{
    pid_t id = fork(); //调用fork函数使父子进程依次启动。
   if(id == 0)
    {
        int cnt = 5;
        // 子进程
       while(1)
        {
           printf("i am child, pid : %d, ppid : %d, g_val: %d, &g_val: %p\n", getpid(), getppid(), g_val, &g_val);
           sleep(1);
            if(cnt) cnt--;
            else {                g_val=200;
                printf("child g_val : 100->200\n");
                cnt--;
           }
        }
    }
    else
    {
        // 父进程
        while(1)
        {
            printf("i am parent, pid : %d, ppid : %d, g_val: %d, &g_val: %p\n", getpid(), getppid(), g_val, &g_val);
           sleep(1);
        }
    }
}
```

运行结果：
<img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B41.png'>

很奇怪，在父子进程分别运行后，g_val看似是两个进程都有的独立个体，但&g_val却又是一样的。这与现学的知识很矛盾，如果g_val地址相同，那么就意味着在子进程中的改变也会影响父进程，但事实并未如此，二者从变化上看又是独立的。
怎么会`同一地址，同一变量`，父子进程分别读取到了不同的内容呢？

>这是因为&g_val是虚拟地址而非物理地址。

平时我们写的指针，也不是物理地址，而通通都是虚拟地址。
那么虚拟地址又是如何转换为物理地址的呢？
这就是此篇文章的主题了。



# 地址空间

## 1和0
计算机中的数据和指令是以二进制形式（0和1）表示的。在数字电子电路中，这两个状态（0和1）通常由高电平（High Level）和低电平（Low Level）来表示。
>高电平（1）：当电信号处于`高电平`状态时，这通常表示逻辑上的`1`。在数字电路中，高电平可以代表“真”（true）状态。在通信系统中，高电平代表“1”比特。
低电平（0）：当电信号处于低电平状态时，这通常表示逻辑上的0。在数字电路中，低电平可以代表“假”（false）状态。在通信系统中，低电平代表“0”比特。

这种二进制的表示方式基于数字电路的特性，其中电子元件（如晶体管和集成电路）的工作原理被设计成可以区分高低电平。这种二进制表示方法是计算机内部数据处理和存储的基础，也是现代计算机系统中所有信息的基础。计算机内部的所有操作，包括数据的处理、存储和传输，都可以通过高低电平来实现。

在一个32位计算机中，通常会有32根数据线和32根地址线。每一根线都只有以`高低电平`的形式来传输`1或者0`。

>32根数据线：这表示计算机可以一次性处理32位（4字节）的数据。每根数据线可以传输一个二进制位（0或1）。
32根地址线：这表示计算机可以寻址2^32个不同的内存位置，每个内存位置都可以存储一个数据单元（通常是1字节）。

这样的设计使得计算机可以处理32位宽的数据块，同时也能够访问大约4GB的内存空间（2^32个地址位置）。

## 地址空间概念与区域划分

>Linux系统中的地址空间通常是一个4GB的虚拟地址空间，它用于给每个进程提供一个独立的内存地址`范围`。这个虚拟地址空间被划分为几个不同的区域，每个区域有`不同的用途`。

也就是说地址空间可以理解为一个范围，在32位计算机里，地址总线的排列组合范围就是空间的范围，也就是[0,2^32]。
划分的概念也很好理解，就像在上小学时，你有没有和同桌互相划过`界限`呢？linux中的区域划分也可以如此类比，线的两边是两个不同的同学，linux里线的两边就是两个不同用途的区域。



## 进程地址空间
进程地址空间是地址空间的一个实例，特定于每个运行的进程。它是操作系统提供的虚拟内存管理的核心组成部分，用于将进程的数据和指令存放在内存中，并提供内存保护、地址映射、隔离等功能。每个进程的地址空间在逻辑上独立，允许多个进程`并发`执行，而它们各自拥有自己的地址空间。
进程地址空间用于描述一个正在运行的进程在内存中的布局和管理方式。每个进程都有其自己的地址空间，它是虚拟内存的抽象表示，允许进程访问物理内存上的数据和指令。
本质上，进程地址空间就是在描述一个进程的`可视范围`的大小。同时在空间内必须要进行`区域的划分`。
进程地址空间通常包括以下组成部分：
>代码段（Text Segment）：也称为可执行段，包含进程的可执行指令。这是程序的机器代码，通常是`只读`的，因为它应该在运行时不被修改。
数据段（Data Segment）：用于`存储进程的全局和静态变量`。这包括初始化的全局变量和静态变量，通常是`可读写`的。
堆（Heap）：用于`动态分配内存`，通常在运行时通过函数（如malloc和free）来进行内存分配和释放。堆的大小通常是可变的，取决于进程的需求。
栈（Stack）：用于`存储函数调用的局部变量和函数的调用信息`。栈是一个后进先出（LIFO）数据结构，用于跟踪函数的调用和返回。栈的大小通常是固定的或者由操作系统动态管理。
堆栈区域之间的未映射空间（Unmapped Area Between Heap and Stack）：这是两者之间的空闲区域，用于防止堆和栈之间的溢出。
内核空间（Kernel Space）：这是由操作系统控制的部分内存，包含操作系统内核的代码和数据。`用户进程不能直接访问内核空间`，而必须通过`系统调用`来请求内核执行操作。

在这里简单画图表示一下。
<img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B43.png'>

每个进程的地址空间`都是虚拟`的，它将虚拟地址映射到物理内存上，这一步由操作系统的内存管理单元（MMU）来完成。`MMU负责将虚拟地址转换为物理地址（中间会用到页表）`，同时实现了内存保护和隔离，确保一个进程无法访问或干扰其他进程的地址空间,这一点会在下面进行解释。

<img src='https://tuchuang-1317757279.cos.ap-chengdu.myqcloud.com/%E8%BF%9B%E7%A8%8B%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B42.png'>

通过上图可以看出，进程的PCB中有指向进程地址空间的指针，进程地址空间中也进行了区域的划分(进程地址都是虚拟的)。同时，进程地址空间本质上也是一个`内核数据对象`，也是像PCB一样是需要`先描述在组织`的。
此时，我们可以更新进程的概念。

>进程本质上是内核数据结构(task_struct and mmu_struct and 页表 )加程序代码与数据。

进程地址空间的概念允许多个进程同时运行，`每个进程都有自己的独立地址空间`，因此它们之间不会相互干扰(可以思考一下如何做到的)。这是操作系统中多任务处理和内存保护的核心原则之一。

说了这么多，os是如何实现虚拟到物理的地址转换，以及这样做的意义是什么呢？
地址转换需要页表的助力。

在这里简单的介绍一下页表。
页表是一种用于虚拟内存管理的关键数据结构，它用于`将进程的虚拟地址映射到物理内存地址`。
虚拟内存是每个进程独立的地址空间，而物理内存是系统上的实际硬件内存。
每个进程都有自己的虚拟地址空间，它由连续的虚拟地址组成，通常从0开始，直到进程的地址空间大小的上限。进程使用虚拟地址来访问内存，而不需要知道物理内存的实际位置。
虚拟地址空间和物理内存都被划分为`固定大小的块`，这些块称为`"页"`。在x86架构中，页的大小通常是4KB。
页表则是一种数据结构，它将虚拟地址映射到物理地址。`每个进程都有自己的页表`，用于跟踪虚拟地址到物理地址的映射关系。
要将虚拟地址转换为物理地址，操作系统需要逐级定位到目标虚拟地址的页表项。一旦找到，就可以通过映射关系获得最终的物理地址。

